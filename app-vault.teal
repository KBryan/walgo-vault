#pragma version 2

// position 0: isAdmin
// position 1: GlobalStatus


// check if the app is being created
// if so save creator
int 0
txn ApplicationID
==
bz not_creation

// Create Application -> Save Creator
txn NumAppArgs
int 0
==
bz failed

byte "Creator"
txn Sender
app_global_put
//0 args must be used on creation

// by default Minter = Creator
byte "MintAccount"
txn Sender
app_global_put

int 1
return

not_creation:
// is it an admin action
byte "Creator"
app_global_get
txn Sender
==

// position 0 == isAdmin
store 0

byte "GlobalStatus"
app_global_get

// position 1 == GlobalStatus
store 1

load 0
bz no_admin

// check if this is deletion ---
int DeleteApplication
txn OnCompletion
==
bnz execute_action

//---
// check if this is update ---
int UpdateApplication
txn OnCompletion
==
bnz execute_action

// All the other admin actions require at least one arg
// If it is the admin account but 0 args -> admin account as a user
txn NumAppArgs
int 1
>=
bz no_admin

txna ApplicationArgs 0
byte "global-status"
==
bz admin_no_global_status

txn NumAppArgs
int 2
==
bz failed

txna ApplicationArgs 1
btoi

dup
store 4

// GlobalStatus can be 0 or 1
int 0
==
load 4
int 1
==
||
bz failed

// adminAccount -> setGlobalStatus(status)
// 'GlobalStatus' -> status
byte "GlobalStatus"
load 4
app_global_put

int 1
return

admin_no_global_status:

txna ApplicationArgs 0
byte "mint-account"
==
bz admin_no_set_mint_account

txn NumAccounts
int 1
==
bz failed

// adminAccount -> setMintAccount(mintAccount)
// 'MintAccount' -> mintAccount
byte "MintAccount"
txn Accounts 1
app_global_put

int 1
return




admin_no_set_mint_account:

txna ApplicationArgs 0
byte "status"
==
bz admin_no_status

txn NumAppArgs
int 2
==
bz failed

txn NumAccounts
int 1
==
bz failed

txna ApplicationArgs 1
btoi

dup
store 4

// status can be 0 or 1
int 0
==
load 4
int 1
==
||
bz failed

// adminAccount -> setAccountStatus(Vault Address, status)
// Vault address = Account1, Vault address: 'status' -> status
int 1
byte "status"
load 4
app_local_put

int 1
return

admin_no_status:

// Unknown action, the admin can have a Vault so the admin account is treated as a user account


no_admin:
// test GlobalStatus
load 1
bz failed

// OptIn
int OptIn
txn OnCompletion
==
bnz opt_in

// CloseOut
int CloseOut
txn OnCompletion
==
bnz close_out

txn NumAppArgs
int 1
>=
bz failed

txna ApplicationArgs 0
byte "register"
==
bz no_admin_no_register

txn NumAppArgs
int 1
==
bz failed

txn NumAccounts
int 1
==
bz failed

// account -> register(Account owner, Vault address)
byte "Program"
//byte base64 ASYBIA==
byte base64 AiADAgboiaMBJgEg
concat
txn Sender
//addr 4YDUBDLNMVD4SBNKZBVUE6B3KA5BWMRNKAD4SWZZAWNMOCC2S4ZDKRTC24
concat
byte base64 MQcoEjIEIg8QMwAQIxIQMwAYJBIQ
//byte base64 MQAoEg==
concat

//byte base64 ASYBICFkn8x6bwiE3yb+ZFRuEiYT8zVRwtOSDIqxn92F2FaCMwEAKBI=
//concat
sha512_256
txn Accounts 1
//addr TXT6BQNYL2MVDDUSDKLNPSU6WRYNBI2RSLTCKMU7EUAZSI4XFG5T7TYJV4
==
bz failed

int 0
txn ApplicationID
byte "vault"
app_local_get_ex
// already registered?
bnz failed

// assign the Vault address to the account. It is possible to calculate this address from the account but we may need it. 
int 0
byte "vault"
txn Accounts 1
app_local_put

// setAccountStatus(1)
int 0
byte "status"
int 1
app_local_put

int 1
return


no_admin_no_register:

// verify if the Account status is enabled
int 0
byte "status"
app_local_get
bz failed

txna ApplicationArgs 0
byte "deposit-algos"
==
bz no_admin_no_deposit

txn NumAppArgs
int 2
==
bz failed

// account -> depositALGOs(Account owner, Vault address)
int 0
txn ApplicationID
byte "vault"
app_local_get_ex
// registered?
bz failed

// is the same Vault that corresponds to the account
gtxn 1 Receiver
==
bz failed

// tx1: App DepositALGOs
// tx2: ALGO transfer
global GroupSize
int 2
==

// ApplicationCall
gtxn 0 TypeEnum
int 6
==
&&

// Payment
gtxn 1 TypeEnum
int 1
==
&&

// more than 0
gtxn 1 Amount
int 0
>
&&

gtxn 1 Amount
txna ApplicationArgs 1
btoi
==
&&

bz failed

int 0
byte "deposits"
app_local_get

//int 67
gtxn 1 Amount
+
store 4

int 0
byte "deposits"
load 4
app_local_put

int 1
return


no_admin_no_deposit:


txna ApplicationArgs 0
byte "mint-walgos"
==
bz no_admin_no_mint

txn NumAppArgs
int 2
==
bz failed

txn NumAccounts
int 1
==
bz failed

// account -> mintwALGOs(Account owner, Vault address, amount)
int 0
txn ApplicationID
byte "vault"
app_local_get_ex
// registered?
bz failed

// is the same Vault that corresponds to the account
txn Accounts 1
==
bz failed

// tx1: App MintwALGOs
// tx2: ASA transfer
global GroupSize
int 2
==
// ApplicationCall
gtxn 0 TypeEnum
int 6
==
&&
// AssetTransfer
gtxn 1 TypeEnum
int 4
==
&&

// check amounts
gtxn 1 AssetAmount
txna ApplicationArgs 1
btoi
==
&&

// more than 0
gtxn 1 AssetAmount
int 0
>
&&

// check account
//gtxn 1 AssetReceiver
//txn Sender
//==
//&&

gtxn 1 Sender
byte "MintAccount"
app_global_get
==
&&

gtxn 1 Fee
global MinTxnFee
==
&&

// no Close
gtxn 1 CloseRemainderTo 
global ZeroAddress
==
&&

// ASA ID
gtxn 1 XferAsset
int 2671688
==
&&

bz failed


int 0
byte "minted"
app_local_get

txna ApplicationArgs 1
btoi
+
store 4

// the ALGO balance must be greater to the total minted wALGOs
int 1
balance
load 4
>=
bz failed

int 0
byte "minted"
load 4
app_local_put

int 1
return


no_admin_no_mint:

txna ApplicationArgs 0
byte "withdraw-algos"
==
bz no_admin_no_withdraw

txn NumAppArgs
int 2
==
bz failed

txn NumAccounts
int 1
==
bz failed

// account -> withdrawALGOs(Account owner, Vault address, amount)
int 0
txn ApplicationID
byte "vault"
app_local_get_ex
// registered?
bz failed

dup
store 5

// is the same Vault that corresponds to the account sending the ALGOs
gtxn 1 Sender
==

// is the same Vault that corresponds to the Accounts[1]
load 5
txn Accounts 1
==
&&

// tx1: App WithdrawALGOs
// tx2: Payment
global GroupSize
int 2
==
&&

// ApplicationCall
gtxn 0 TypeEnum
int 6
==
&&

// Payment
gtxn 1 TypeEnum
int 1
==
&&

// check amounts
gtxn 1 Amount
txna ApplicationArgs 1
btoi
==
&&

// more than 0
gtxn 1 Amount
int 0
>
&&

// check account
gtxn 1 Receiver
txn Sender
==
&&

gtxn 1 Fee
global MinTxnFee
==
&&

// no Close
gtxn 1 CloseRemainderTo 
global ZeroAddress
==
&&

bz failed

// the ALGO balance - withdraw amount - Fee must be greater to the total minted wALGOs
int 1
balance

gtxn 1 Amount
-
gtxn 1 Fee
-

int 0
byte "minted"
app_local_get
>=
bz failed

int 1
return





no_admin_no_withdraw:


txna ApplicationArgs 0
byte "burn-walgos"
==
bz no_admin_no_burn

txn NumAppArgs
int 2
==
bz failed

// account -> burnwALGOs(Account owner, Vault address, amount)
int 0
txn ApplicationID
byte "vault"
app_local_get_ex
// registered?
bz failed

// tx1: App BurnwALGOs
// tx2: ASA transfer to Minter
global GroupSize
int 2
==
// ApplicationCall
gtxn 0 TypeEnum
int 6
==
&&
// AssetTransfer
gtxn 1 TypeEnum
int 4
==
&&

// check amounts
gtxn 1 AssetAmount
txna ApplicationArgs 1
btoi
==
&&

// more than 0
gtxn 1 AssetAmount
int 0
>
&&

// Minter == ASA Receiver
gtxn 1 AssetReceiver
byte "MintAccount"
app_global_get
==
&&

// ASA ID
gtxn 1 XferAsset
int 2671688
==
&&

bz failed

int 0
byte "minted"
app_local_get

dup
store 4

// amount to burn greater or equal to amount minted
gtxn 1 AssetAmount
>=
bz failed

load 4
gtxn 1 AssetAmount
-
store 4

int 0
byte "minted"
load 4
app_local_put

int 1
return

no_admin_no_burn:

// unknown call
int 0
return






failed:
int 0
return
opt_in:
close_out:
finished:
execute_action:
int 1
return