#pragma version 2

// Global Vars:
// position 0: isAdmin
// position 2: is registered
// position 3: Vault address (no Admin operations)
// position 4: Admin address

// check if the app is being created
// if so save creator
int 0
txn ApplicationID
==
bz not_creation

//
// BEGIN: Creation of the app
// ==========================
//

global GroupSize
int 1
==
bz failed

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 0
//==
//bz failed

// Admin -> createApp: args []
// Save Creator
byte "A" // Admin
txn Sender
app_global_put

// by default Minter = Owner
byte "MA" // MintAccount
txn Sender
app_global_put

// GS (GlobalStatus) starts disabled

b success

//
// END: Creation of the app
//
/////////////////////////////////////////////////////////////////////

not_creation:
// is it an admin action
byte "A" // Admin
app_global_get

dup
store 4
txn Sender
==
bz no_admin









//
// BEGIN: ADMIN SECTION
// ====================
//

// Handle each possible OnCompletion type for admin

txn OnCompletion
int DeleteApplication
==
bnz admin_handle_delete

txn OnCompletion
int UpdateApplication
==
bnz admin_handle_update

txn OnCompletion
int NoOp
==
bnz admin_handle_noop

// OnCompletion value is either OptIn, CloseOut, or ClearState
// This is forbidden as admin, as admin is the creator
err

// Handle Admin Delete
// -------------------
// Admin -> deleteApp: args []
admin_handle_delete:

global GroupSize
int 1
==
bnz success

err

// Handle Admin Update
// -------------------
// Admin -> updateApp: args []
admin_handle_update:

global GroupSize
int 1
==
bnz success

err

// Handle Admin NoOp
// -----------------
admin_handle_noop:


// SAVE SPACE: it fails if does not have 2 args so do not ask it 
// All the other admin actions require at least one arg
// If it is the admin account but 0 args -> admin account as a user
//txn NumAppArgs
//int 1
//>=
//bz no_admin

txna ApplicationArgs 0
byte "sGS" // setGlobalStatus
==
bz admin_no_global_status

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

global GroupSize
int 1
==
bz failed

txna ApplicationArgs 1
btoi

dup
store 8

// GlobalStatus can be 0 or 1
int 0
==
load 8
int 1
==
||
bz failed

// Admin -> setGlobalStatus: args ['sGS', 0|1]
byte "GS" // GlobalStatus
load 8
app_global_put

b success
/////////////////////////////////////////////////////////////////////


admin_no_global_status:
txna ApplicationArgs 0
byte "wAF" // withdrawAdminFee
==
bz admin_no_withdraw_admin_fee

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

//txn NumAccounts
//int 1
//==
//bz failed


// admin -> withdrawAdminFee: args: ['waf'] accounts: [account]

int 1
txn ApplicationID
byte "v" // vault
app_local_get_ex
// registered?
bz failed
store 3 // Vault address

// tx1: App withdrawAdminFee
// tx2: Payment
global GroupSize
int 2
==

// is the same Vault that corresponds to the account sending the ALGOs
load 3
gtxn 1 Sender
==
&&

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
// ApplicationCall
//txn TypeEnum
//int 6
//==
//&&

// Payment
gtxn 1 TypeEnum
int 1
==
&&

// check account: tx1 Receiver == txn Sender == Admin
gtxn 1 Receiver
txn Sender
==
&&

gtxn 1 Fee
global MinTxnFee
==
&&

// no Close
gtxn 1 CloseRemainderTo 
global ZeroAddress
==
&&

bz failed

// store amount to verify
gtxn 1 Amount
//txna ApplicationArgs 1
//btoi

store 7

// substract to fees
int 1
byte "fees"
app_local_get

load 7
-
store 8

int 1
byte "fees" // fees = fees - amountWithdrew - txFee
load 8
app_local_put

b success
/////////////////////////////////////////////////////////////////////


admin_no_withdraw_admin_fee:
// all the rest admin operations require only 1 tx
global GroupSize
int 1
==
bz failed


txna ApplicationArgs 0
byte "sMA" // setMintAccount
==
bz admin_no_set_mint_account

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAccounts
//int 1
//==
//bz failed

// Admin -> setMintAccount: args ['sMA'] accounts: [New Mint account]
byte "MA" // MintAccount
txn Accounts 1
app_global_put

b success
/////////////////////////////////////////////////////////////////////


admin_no_set_mint_account:
txna ApplicationArgs 0
byte "sAA" // setAdminAccount
==
bz admin_no_set_admin_account

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAccounts
//int 1
//==
//bz failed

// Admin -> setAdminAccount: args ['sAA'] accounts: [New Admin]
byte "A" // Admin
txn Accounts 1
app_global_put

b success
/////////////////////////////////////////////////////////////////////



admin_no_set_admin_account:
txna ApplicationArgs 0
byte "sAS" // setAccountStatus
==
bz admin_no_status

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

//txn NumAccounts
//int 1
//==
//bz failed

txna ApplicationArgs 1
btoi

dup
store 8

// status can be 0 or 1
int 0
==
load 8
int 1
==
||
bz failed

// Admin -> setAccountStatus: args ['s', 0|1] accounts: [account to enable/disable]
int 1
byte "s" // status
load 8
app_local_put

b success
/////////////////////////////////////////////////////////////////////

admin_no_status:


txna ApplicationArgs 0
byte "sMF" // setMintFee
==
bz admin_no_mint_fee

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

// Admin -> setMintFee: args ['sMF', 0-5000]
txna ApplicationArgs 1
btoi

dup
store 8


// mint fee between 0 and 5000 (0%-50%)
int 0
>=
load 8
int 5000
<=
&&
bz failed

byte "MF" // MintFee
load 8
app_global_put

int 1
return

admin_no_mint_fee:

txna ApplicationArgs 0
byte "sBF" // setBurnFee
==
bz admin_no_burn_fee

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

// Admin -> setBurnFee: args ['sBF', 0-5000]
txna ApplicationArgs 1
btoi

dup
store 8


// burn fee between 0 and 5000 (0%-50%)
int 0
>=
load 8
int 5000
<=
&&
bz failed

byte "BF" // BurnFee
load 8
app_global_put

b success


admin_no_burn_fee:

txna ApplicationArgs 0
byte "sCF" // setCreationFee
==
bz admin_no_creation_fee

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

// Admin -> setCreationFee: args ['sCF', int (microALGOs)]

byte "CF" // BurnFee
txna ApplicationArgs 1
btoi
app_global_put

b success


admin_no_creation_fee:


// Unknown action, the admin can have a Vault so the admin account is treated as a user account


no_admin:

// Fail is GlobalStatus = 0
byte "GS" // GlobalStatus
app_global_get
bz failed


// OptIn
int OptIn
txn OnCompletion
==
bz no_admin_no_opt_in

// SAVE SPACE: it fails if does not have 1 account so do not ask it 
// Vault balance needs to be 0 to prevent a user from calling ClearState and then use the balance without returning the minted wALGOs
//txn NumAccounts
//int 1
//==
//bz failed

// GroupSize == 1 && CreationFee == 0 || GroupSize == 2 && CreationFee > 0
global GroupSize
int 1
==
int 0
byte "CF"
app_global_get
dup
store 8
==
&&
bnz optin_no_creation_fee

global GroupSize
int 2
==
// creation fee != 0
load 8
int 0
>
&&

bz failed

gtxn 1 TypeEnum
int 1
==

// Receiver account == Admin
gtxn 1 Receiver 
load 4
==
&&

// amount sent == CreationFee
gtxn 1 Amount
load 8
>=
&&

bz failed

optin_no_creation_fee:
int 1
balance
int 0
==
bz failed

// account -> optIn: args [] accounts: [vaultAddr]
byte "Program"
//byte base64 AiABtrijASYBIA==
byte base64 AiABoNejASYBIA==
concat

txn Sender
concat

byte base64 MQcoEkgzABgiEg==
concat

sha512_256

dup
store 8

// verify that we are verifying the balance of the same account
txn Accounts 1
==
bz failed

// assign the Vault address to the account
int 0
byte "v" // vault
load 8
app_local_put

// account -> setAccountStatus: args ['s', 1|0]
int 0
byte "s" // status
int 1
app_local_put

b success
/////////////////////////////////////////////////////////////////////




no_admin_no_opt_in:
// all operations have 2 txs
global GroupSize
int 2
==
bz failed

int 0
txn ApplicationID
byte "v" // vault
app_local_get_ex
// registered?
bz failed // not registered?

store 3 // Vault address

// CloseOut
int CloseOut
txn OnCompletion
==
bz no_admin_no_close_out

// account -> CloseOut: args [] accounts: [vaultAddr]

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 1
//==
//bz failed

//txn NumAccounts
//int 1
//==
//bz failed


int 0
store 7

txna Accounts 0
store 8

// Amount should be == pending Admin fees
gtxn 1 Amount
store 5


// Position 3: Vault address
// Position 4: Admin address
// Position 5: tx1.Amount to cover pending Admin fees
// Position 7: Index on the Accounts array of the account to close

close_out_account:

// tx1: App CloseOut
// tx2: Payment

// tx0.TypeEnum == AppCall && tx0.TypeEnum == Payment && tx1.Sender == VaultAddr && GroupSize == 2 && tx1.Fee == MinTxnFee && tx1.Receiver == Admin && Minted == 0 && tx1.To == pendingFees
// Payment
gtxn 1 TypeEnum
int 1
==

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
// ApplicationCall
//txn TypeEnum
//int 6
//==
//&&

// is the same Vault that corresponds to the account sending the ALGOs
load 3
gtxn 1 Sender
==
&&

global GroupSize
int 2
==
&&

gtxn 1 Fee
global MinTxnFee
==
&&

// Receiver account == Admin
gtxn 1 Receiver 
load 4
==
&&

// user should burn the algos before CloseOut
load 7
byte "m" // minted
app_local_get

int 0
==
&&

load 7
byte "fees" // fees owed
app_local_get

// Receiver (Admin) amount == pending Admin fees
load 5
==
&&
bz failed

b success



no_admin_no_close_out:
// SAVE SPACE: it fails if does not have 2 args so do not ask it 
// Operations have at least one argument that specifies the operation
//txn NumAppArgs
//int 1
//>=

// verify if the Account status is enabled
int 0
byte "s" // status
app_local_get
bz failed


txna ApplicationArgs 0
byte "mw" // mintwALGOs
==
bz no_admin_no_mint

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

//txn NumAccounts
//int 1
//==
//bz failed

// account -> mintwALGOs: args ['mw'] accounts: [vaultAddr]

// is the same Vault that corresponds to the account
load 3
txn Accounts 1
==
bz failed

// tx1: App MintwALGOs
// tx2: ASA transfer
// AssetTransfer
gtxn 1 TypeEnum
int 4
==

// ApplicationCall
//txn TypeEnum
//int 6
//==
//&&

// more than 0
gtxn 1 AssetAmount
int 0
>
&&

// check account
// necessary?
//gtxn 1 AssetReceiver
//txn Sender
//==
//&&

gtxn 1 Sender
byte "MA" // MintAccount
app_global_get
==
&&

gtxn 1 Fee
global MinTxnFee
==
&&

// no Close
gtxn 1 AssetCloseTo 
global ZeroAddress
==
&&

// ASA ID
gtxn 1 XferAsset
int 2671688
==
&&

bz failed


int 0
byte "m" // minted
app_local_get

//txna ApplicationArgs 1
//btoi
gtxn 1 AssetAmount
dup
dup
// amount to tax
store 8
// amount minting to verify 
store 7
+
store 6

int 0
byte "m" // minted
load 6
app_local_put

// add the fee to owner account
byte "MF"
app_global_get

store 9
int 1 
store 6

int 0
store 7

// Position 6: verify balance == 1 (true)
// Position 7: 0 because "m" has the amount to mint included 
// Position 8: mint amount, amount to tax
// Position 9: mint fee, tax
b charge_fees




no_admin_no_mint:

txna ApplicationArgs 0
byte "wA" // withdrawALGOs
==
bz no_admin_no_withdraw

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

//txn NumAccounts
//int 1
//==
//bz failed


// account -> withdrawALGOs: args: ['wA'] accounts: [vaultAddr]

// tx1: App withdrawALGOs
// tx2: Payment

// is the same Vault that corresponds to the Accounts[1]
load 3 // vault address
txna Accounts 1
==
//&&

// is the same Vault that corresponds to the account sending the ALGOs
load 3
gtxn 1 Sender
==
&&

// ApplicationCall
//txn TypeEnum
//int 6
//==
//&&

// Payment
gtxn 1 TypeEnum
int 1
==
&&

// check amounts
gtxn 1 Amount
store 7

// more than 1000 (Minimum Withdrawal)
load 7
int 1000
>=
&&

// check account: it is not necessary, the user can withdraw to any account
//gtxn 1 Receiver
//txn Sender
//==
//&&

gtxn 1 Fee
global MinTxnFee
==
&&

// no Close
gtxn 1 CloseRemainderTo 
global ZeroAddress
==
&&

bz failed

// the total amount to validate is withdrawal amount + txFee
load 7
dup
store 8
gtxn 1 Fee
//int 1000
+
store 7

int 1
store 6

// Position 6: verify balance == 1
// Position 7: verify amount to withdraw/mint (Mint/Withdraw) or 0 if it is not necessary (Burn/Deposit)

b verify_balance


no_admin_no_withdraw:


txna ApplicationArgs 0
byte "bw" // burnwALGOs
==
bz no_admin_no_burn

// SAVE SPACE: it fails if does not have 2 args so do not ask it 
//txn NumAppArgs
//int 2
//==
//bz failed

// account -> burnwALGOs: args: ['bw']

// tx1: App BurnwALGOs
// tx2: ASA transfer to Minter
// ApplicationCall
//txn 0 TypeEnum
//int 6
//==
// AssetTransfer
gtxn 1 TypeEnum
int 4
==
//&&

// more than 0
gtxn 1 AssetAmount
int 0
>
&&

// Minter == ASA Receiver
gtxn 1 AssetReceiver
byte "MA" // MintAccount
app_global_get
==
&&

// ASA ID
gtxn 1 XferAsset
int 2671688
==
&&

bz failed

int 0
byte "m" // minted
app_local_get

dup
store 8

// amount to burn less or equal to amount minted. If it is not verified the next substraction generates an error if the 
// the amount burned is greater than the minted. 
gtxn 1 AssetAmount
//txna ApplicationArgs 1
//btoi
>=
bz failed

load 8
gtxn 1 AssetAmount
//txna ApplicationArgs 1
//btoi
-
store 8

int 0
byte "m" // minted
load 8
app_local_put

// add the fee to owner account
byte "BF"
app_global_get

store 9
gtxn 1 AssetAmount
//txna ApplicationArgs 1
//btoi
store 8
int 0
store 6

// Position 6: 0 Do not verify balances, 1 verify balances
// Position 7: balance to verify if Position 6 != 0
// Position 8: mint/burn amount, amount to tax
// Position 9: fee to tax

charge_fees:

load 8
load 9
*
int 10000
/
// Position 8: fees to add
store 8

int 0
byte "fees" // fees = fees + newFees
app_local_get

// tax fee
load 8
+
store 8

int 0
byte "fees"
load 8
app_local_put

load 6
int 0
==
bnz success

// Position 6: use this amount as minted
// Position 7: amount to Withdraw/Burn. It must be less than the balance - AdminFees. Withdraw amount must include tx fees

verify_balance:

// Balance - withdraw/mint amount - fees >= amount minted
int 0
byte "fees" 
app_local_get
dup
store 8
int 0
>
bz verify_balance_no_fees

// keep a tx fee to withdraw/close
load 8
global MinTxnFee
+
store 8

verify_balance_no_fees:

// Balance - WithdrawalAmount - AdminFees >= Minted
// Keep also MinTxFee in the account to withdraw/close it

// Vault Balance
int 1
balance

// Withdraw amount
load 7
-

// admin fees
load 8
-

int 0
byte "m" // minted
app_local_get

>=
bz failed

b success
/////////////////////////////////////////////////////////////////////


no_admin_no_burn:

// unknown call
//b failed
/////////////////////////////////////////////////////////////////////



failed:
int 0
return

success:
int 1
return