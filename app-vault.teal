#pragma version 2

// position 0: isAdmin
// position 1: GlobalStatus
// position 2: is registered
// position 3: vault address

// check if the app is being created
// if so save creator
int 0
txn ApplicationID
==
bz not_creation

txn NumAppArgs
int 0
==
bz failed

// Admin -> createApp: args []
// Save Creator
byte "A" // Admin
txn Sender
app_global_put
//0 args must be used on creation

// by default Minter = Owner
byte "MA" // MintAccount
txn Sender
app_global_put

// GS (GlobalStatus) starts disabled

int 1
return

not_creation:
// is it an admin action
byte "A" // Owner
app_global_get
txn Sender
==

// position 0 == isAdmin
store 0

byte "GS" // GlobalStatus
app_global_get

// position 1 == GlobalStatus
store 1

load 0
bz no_admin

// check if this is deletion ---
int DeleteApplication
txn OnCompletion
==
bnz execute_action
// Admin -> deleteApp: args []


//---
// check if this is update ---
int UpdateApplication
txn OnCompletion
==
bz admin_no_update

// Admin -> updateApp: args []

// execute update actions
//byte "A" // Owner
//txn Sender
//app_global_put

b execute_action

admin_no_update:
// All the other admin actions require at least one arg
// If it is the admin account but 0 args -> admin account as a user
txn NumAppArgs
int 1
>=
bz no_admin

txna ApplicationArgs 0
byte "sGS" // setGlobalStatus
==
bz admin_no_global_status

txn NumAppArgs
int 2
==
bz failed

txna ApplicationArgs 1
btoi

dup
store 8

// GlobalStatus can be 0 or 1
int 0
==
load 8
int 1
==
||
bz failed

// Admin -> setGlobalStatus: args ['sGS', 0|1]
byte "GS" // GlobalStatus
load 8
app_global_put

int 1
return

admin_no_global_status:

txna ApplicationArgs 0
byte "sMA" // setMintAccount
==
bz admin_no_set_mint_account

txn NumAccounts
int 1
==
bz failed

// Admin -> setMintAccount: args ['sMA'] accounts: [New Mint account]
byte "MA" // MintAccount
txn Accounts 1
app_global_put

int 1
return


admin_no_set_mint_account:
txna ApplicationArgs 0
byte "sAA" // setAdminAccount
==
bz admin_no_set_admin_account

txn NumAccounts
int 1
==
bz failed

// Admin -> setAdminAccount: args ['sAA'] accounts: [New Admin]
byte "A" // Admin
txn Accounts 1
app_global_put

int 1
return




admin_no_set_admin_account:
txna ApplicationArgs 0
byte "sAS" // setAccountStatus
==
bz admin_no_status

txn NumAppArgs
int 2
==
bz failed

txn NumAccounts
int 1
==
bz failed

txna ApplicationArgs 1
btoi

dup
store 8

// status can be 0 or 1
int 0
==
load 8
int 1
==
||
bz failed

// Admin -> setAccountStatus: args ['s', 0-5000] accounts: [account to enable/disable]
int 1
byte "s" // status
load 8
app_local_put

int 1
return

admin_no_status:

txna ApplicationArgs 0
byte "sMF" // setMintFee
==
bz admin_no_mintfee

txn NumAppArgs
int 2
==
bz failed

// Admin -> setMintFee: args ['sMF', 0-5000]
txna ApplicationArgs 1
btoi

dup
store 8


// mint fee can between 0 and 5000 (0%-50%)
int 0
>=
load 8
int 5000
<=
&&
bz failed

byte "MF" // MintFee
load 8
app_global_put

int 1
return


admin_no_mintfee:

txna ApplicationArgs 0
byte "sRF" // setRewardsFee
==
bz admin_no_rewardsfee

txn NumAppArgs
int 2
==
bz failed

// Admin -> setRewardsFee: args ['sRF', 0-5000]
txna ApplicationArgs 1
btoi

dup
store 8


// mint fee can between 0 and 5000 (0%-50%)
int 0
>=
load 8
int 5000
<=
&&
bz failed

byte "RF" // RewardsFee
load 8
app_global_put

int 1
return

admin_no_rewardsfee:


// Unknown action, the admin can have a Vault so the admin account is treated as a user account


no_admin:

// test GlobalStatus
load 1
bz failed

int 0
txn ApplicationID
byte "v" // vault
app_local_get_ex
// registered?
store 2 // is registered
store 3 // Vault address


no_admin_optin:
// OptIn
int OptIn
txn OnCompletion
==
bz no_admin_no_opt_in

load 2
bnz failed // already registered

// account -> optIn: args []
byte "Program"
// App Id 2674653
//byte base64 AiADAgbdn6MBJgEg
// App Id 2677814
byte base64 AiADAga2uKMBJgEg
concat

txn Sender
concat

byte base64 MQcoEjIEIg8QMwAQIxIQMwAYJBIQ
concat


//byte base64 AiADAgboiaMBJgEg
//concat
//txn Sender
//concat
//byte base64 MQcoEjIEIg8QMwAQIxIQMwAYJBIQ
//concat

sha512_256

store 8

// assign the Vault address to the account
int 0
byte "v" // vault
load 8
app_local_put

// account -> setAccountStatus: args ['s', 1|0]
int 0
byte "s" // status
int 1
app_local_put

int 1
return




no_admin_no_opt_in:
load 2
bz failed // not registered?

// CloseOut
int CloseOut
txn OnCompletion
==
bnz close_out

// Operations have at least one argument that specifies the operation
txn NumAppArgs
int 1
>=
bz failed

// verify if the Account status is enabled
int 0
byte "s" // status
app_local_get
bz failed

txna ApplicationArgs 0
byte "dA" // depositALGOs
==
bz no_admin_no_deposit

txn NumAppArgs
int 2
==
bz failed

// account -> depositALGOs: args ['dA', amount]

load 3 // Vault address

// is the same Vault that corresponds to the account
gtxn 1 Receiver
==
bz failed

// tx1: App DepositALGOs
// tx2: ALGO transfer
global GroupSize
int 2
==

// ApplicationCall
gtxn 0 TypeEnum
int 6
==
&&

// Payment
gtxn 1 TypeEnum
int 1
==
&&

// more than 0
gtxn 1 Amount
int 0
>
&&

gtxn 1 Amount
txna ApplicationArgs 1
btoi
==
&&

bz failed

int 0
byte "d" // deposited
app_local_get

//int 67
gtxn 1 Amount
+
store 8

int 0
byte "d" // deposited
load 8
app_local_put

int 1
return


no_admin_no_deposit:

txna ApplicationArgs 0
byte "mw" // mintwALGOs
==
bz no_admin_no_mint

txn NumAppArgs
int 2
==
bz failed

txn NumAccounts
int 1
==
bz failed

// account -> mintwALGOs: args ['mw', amount] accounts: [vaultAddr]

// is the same Vault that corresponds to the account
load 3
txn Accounts 1
==
bz failed

// tx1: App MintwALGOs
// tx2: ASA transfer
//global GroupSize
//int 2
//==
// ApplicationCall
txn TypeEnum
int 6
==
//&&
// AssetTransfer
//gtxn 1 TypeEnum
//int 4
//==
//&&

// check amounts
//gtxn 1 AssetAmount
//txna ApplicationArgs 1
//btoi
//==
//&&

// more than 0
//gtxn 1 AssetAmount
//int 0
//>
//&&

// check account
// necessary?
//gtxn 1 AssetReceiver
//txn Sender
//==
//&&

//gtxn 1 Sender
//byte "MA" // MintAccount
//app_global_get
//==
//&&

//gtxn 1 Fee
//global MinTxnFee
//==
//&&

// no Close
//gtxn 1 CloseRemainderTo 
//global ZeroAddress
//==
//&&

// ASA ID
//gtxn 1 XferAsset
//int 2671688
//==
//&&

bz failed


int 0
byte "m" // minted
app_local_get

txna ApplicationArgs 1
btoi
//gtxn 1 AssetAmount
+
store 8

// the ALGO balance must be greater to the total minted wALGOs
int 1
balance
load 8
>=
bz failed

int 0
byte "m" // minted
load 8
app_local_put




// add the fee to owner account
byte "MF"
app_global_get

txna ApplicationArgs 1
btoi
//gtxn 1 AssetAmount
*
int 10000
/
store 5

byte "WF"
dup
app_global_get
load 5
+
app_global_put // "WF" = old "WF" + newFee





int 1
return


no_admin_no_mint:

txna ApplicationArgs 0
byte "wA" // withdrawALGOs
==
bz no_admin_no_withdraw

txn NumAppArgs
int 2
==
bz failed

txn NumAccounts
int 1
==
bz failed


// account -> withdrawALGOs: args: ['wA', amount] accounts: [vaultAddr]

// is the same Vault that corresponds to the account sending the ALGOs
load 3
gtxn 1 Sender
==

// is the same Vault that corresponds to the Accounts[1]
load 3 // vault address
txna Accounts 1
==
&&

// tx1: App withdrawALGOs
// tx2: Payment
global GroupSize
int 2
==
&&

// ApplicationCall
txn TypeEnum
int 6
==
&&

// Payment
gtxn 1 TypeEnum
int 1
==
&&

// check amounts
gtxn 1 Amount
txna ApplicationArgs 1
btoi
==
&&

// more than 1000 (Minimum Withdrawal)
gtxn 1 Amount
int 1000
>=
&&

// check account
gtxn 1 Receiver
txn Sender
==
&&

gtxn 1 Fee
global MinTxnFee
==
&&

// no Close
gtxn 1 CloseRemainderTo 
global ZeroAddress
==
&&

bz failed

// calculate the OwnerRewardsFees
// OwnerRewardsFees = (TheoricalBalance + Withdrawal - Deposits) * RewardsFee

// TheoricalBalance = Balance + WithdrewRewardsFees
int 1
balance

int 0
byte "wrf" // withdrew rewards fees
app_local_get
+

dup
store 6

int 0
byte "w" // withdrawals
app_local_get

+
dup
store 8

int 0
byte "d" // deposits
app_local_get
dup
store 9

// if rewards is 0 or less. It can be less to 0 if the real rewards is near 0 and the txs fees are greater than the fess paid
>
bnz greater_than_zero_rewards

// 0 or less rewards
int 0
store 7

b put_rewards_fee

greater_than_zero_rewards:
load 8
load 9
-

byte "RF" // Rewards Fee
app_global_get

*

int 10000
/

store 7

put_rewards_fee:

int 0
byte "rf" // rewards fees
load 7
app_local_put



// TheoricalBalance - AmountToWithdraw - Fee - OwnerRewardsFees >= MintedwALGOs
load 6

//gtxn 1 Amount
txn ApplicationArgs 1
btoi
-
//gtxn 1 Fee
int 1000
-
load 7 // OwnerRewardsFees
-

int 0
byte "m" // minted
app_local_get
>=
bz failed

// keep track of the amount withdrew
int 0
byte "w" // withdrawals
app_local_get

//gtxn 1 Amount
txn ApplicationArgs 1
btoi
+
store 8

int 0
byte "w" // withdrawals
load 8
app_local_put

int 1
return

no_admin_no_withdraw:


txna ApplicationArgs 0
byte "bw" // burnwALGOs
==
bz no_admin_no_burn

txn NumAppArgs
int 2
==
bz failed

// account -> burnwALGOs: args: ['bw', amount]

// tx1: App BurnwALGOs
// tx2: ASA transfer to Minter
global GroupSize
int 2
==
// ApplicationCall
gtxn 0 TypeEnum
int 6
==
&&
// AssetTransfer
gtxn 1 TypeEnum
int 4
==
&&

// check amounts
gtxn 1 AssetAmount
txna ApplicationArgs 1
btoi
==
&&

// more than 0
gtxn 1 AssetAmount
int 0
>
&&

// Minter == ASA Receiver
gtxn 1 AssetReceiver
byte "MA" // MintAccount
app_global_get
==
&&

// ASA ID
gtxn 1 XferAsset
int 2671688
==
&&

bz failed

int 0
byte "m" // minted
app_local_get

dup
store 8

// amount to burn greater or equal to amount minted
gtxn 1 AssetAmount
>=
bz failed

load 8
gtxn 1 AssetAmount
-
store 8

int 0
byte "m" // minted
load 8
app_local_put


int 1
return

no_admin_no_burn:

// unknown call
int 0
return





failed:
int 0
return
opt_in:
close_out:
finished:
execute_action:
int 1
return